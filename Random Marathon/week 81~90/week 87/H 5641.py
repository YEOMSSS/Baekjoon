# Authored by : marigold2003
# Date : 2026-02-02
# Link : https://www.acmicpc.net/problem/5641

import sys

input = sys.stdin.readline


# [Summary]

# 겉보기에 소수는 1보다 크고 t보다 작거나 같은 수로 나누어 떨어지지 않는 양의정수.
# 겉보기에 쌍둥이 소수는 차이가 2인 두 겉보기에 소수.
# n자리인 아무 겉보기에 쌍둥이 소수 쌍에서 작은 수를 출력해라.


def main() -> None:

    # [Ideas]

    # n이 무지막지하게 크다. 최소 3500 최대 5000. 엄청 큰 수에 대한 연산이다.
    # 다만 t는 8000까지만 들어오니 충분히 연산할 수 있다.
    # 에라토스테네스의 체를 딱 t까지만 확인해서 겉보기에 소수 판정을 하면 된다.

    # 아니 근데 n이 너무 크지 않나 이거?
    # 8000보다 큰 소수들을 조합해서 3500~5000자리를 전부 만들어놓는 편이 좋으려나...
    # 그래, 8009가 지금 가장 작은 소수다. 이걸 제곱하면서 원하는 자릿수를 만들자.
    # 상용로그 씌워서 더하면 그게 최종 자릿수가 되니까.

    # 이러면 체를 칠 필요조차 없는 거 아님?
    # 8009와 10007을 곱해서 모든 걸 만들어낼 수 있다.
    # 근데 이래서는 쌍둥이 소수는 구할 수 없다. 아 이거 뭐지 이게

    # 8000 이하의 소수를 전부 곱해서 1을 빼면 나머지의 정리에 의해
    # 8000 이하의 소수로 나눠지지 않는 겉보기에 소수가 된다.
    # 이게 무슨 의미가 있지?

    # 어떤 수가 있다. 그 수에 1을 더하거나 빼면 원래 그 수의 소인수로는 나눠질 수 없게 된다.
    # 8000 이하의 모든 소수를 곱하고 거기에 2*5를 계속 곱하면 모든 자릿수를 만들 수 있다.
    # 거기서 1을 빼고 1을 더하면 겉보기에 쌍둥이인 소수가 되는 것이다.

    # 와 나 진짜 미치겠네...

    ##########

    sieve = [True] * 8001

    # 체로 거르기. i는 isqrt 8000 까지만 확인
    for i in range(2, int(8000**0.5) + 1):
        if sieve[i]:
            for j in range(i * i, 8001, i):
                sieve[j] = False

    # 8000까지의 모든 소수 곱하기. 3421자리다.
    ans = 1
    for i in range(2, 8001):
        if sieve[i]:
            ans *= i

    while True:
        n, t = map(int, input().split())
        if n == 0:
            return

        # 소수의 곱에 2*5를 계속 곱해 원하는 자릿수를 만들고 1을 빼면
        # "소수의 곱 - 1" + "99999.....9" 가 된다.
        print(ans - 1, end="")
        print("9" * (n - 3421), end="")
        # 다음 입력을 위한 공백 출력
        print()

    ##########

    return


# [Review]

# 어지럽네 아... 난이도 매기기 애매하네

if __name__ == "__main__":
    main()
