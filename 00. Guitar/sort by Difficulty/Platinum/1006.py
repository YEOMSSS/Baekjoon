# Authored by : marigold2003
# Date : 2026-02-01
# Link : https://www.acmicpc.net/problem/1006

import sys

input = sys.stdin.readline


# [Summary]

# W명으로 구성된 특수소대를 원타곤에 투입할 것이다.
# 원타곤은 N*2개구역이 원형으로 둘러싸여져 있는 구조다.

# 한 특수소대는 한 구역을 처리할 수 있고, 인접한 구역을 하나 더 처리할 수 있다.
# 구역의 합이 W보다 크지 않아야 처리가 가능하다.
# 한 구역을 두 특수소대가 처리하는 것은 불가능하다.

# 최소 몇개소대가 필요한지 구하시오.


def main() -> None:

    # [Ideas]

    # 일단 인접구역이랑 합해서 W를 넘어가면 그 구역에 1개소대를 편성한다.
    # 그리고 남은 구역들을 최대한 둘씩 묶어서 편성해야 한다.

    # 근데 이게 인접구역만 묶을 수 있다보니 그리디로는 안 된다. 이건 절대 아님.
    # 그렇다는 건 사실 모든 구역을 확인해봐야 한다는 건데, 브루트포스도 안 된다.
    # 남는 건 dp밖에 없네? 2n타일링문제 냄새도 좀 나고 한다. 근데 이제 원형인

    ##########

    T = int(input())

    for _ in range(T):
        N, W = map(int, input().split())
        enemies = tuple(tuple(map(int, input().split())) for _ in range(2))

        # 점화식이 어떻게 될까?
        # 현재열이 위칸만 찬 경우, 아래칸만 찬 경우, 모두 찬 경우.

        # 위칸은 앞이 아래칸만 차있을때 위를 연결하거나 앞이 딱떨어질때 위만 하나 채우기

        # 아래칸은 앞이 위칸만 차있을때 아래를 연결하거나 앞이 딱떨어질때 아래만 하나 채우기

        # 다찬경우는 앞이 다차있을때 위아래를 연결해서 채우는 경우,
        # 이번칸 위칸이 찼을때 아래를 채우는 경우, 이번칸 아래가 찼을때 위를 채우는 경우

        # i열이 위칸만 찬 경우, 아래칸만 찬 경우, 모두 찬 경우로 저장
        dp = [[0, 0, 0] for _ in range(N + 2)]

        # 근데 이제 원형이니까, 연결부를 정해야한다. 위칸연결, 아래칸연결, 연결없음
        # 이렇게 dp를 세 번 돌리면 되지 않을까?

        # 위칸연결은 위칸 하나 채우고 dp[N]의 위칸만 찬 경우 가져오기

        # 아래칸연결은 아래칸 하나 채우고 dp[N]의 아래칸만 찬 경우 가져오기

        # 연결없음은 그냥 해서 dp[N]의 모두 찬 경우 가져오기

        # 위칸에 하나 배치, 아래칸에 하나 배치, 위아래 연결 가능여부 판단 후 불가능시 각각 배치
        dp[0] = [1, 1, 1 + (enemies[0][0] + enemies[1][0] > W)]

        for i in range(1, N + 1):
            1 == 1

        print(dp)

    ##########

    return


# [Review]

# 갑자기 피갤 보고 초라기가 풀고싶어져서 풀었다.
# 나도 처음엔 이 문제가 무서웠는데.

if __name__ == "__main__":
    main()
